# 用栈方式

鸿蒙内核有 6 个汇编文件，读不懂它们就真的很难理解以下问题.

1. 系统调用是如何实现的？

2. CPU 是如何切换任务和进程上下文的？

3. 硬件中断是如何处理的？

4. main 函数到底是怎么来的？

5. 开机最开始发生了什么？

6. 关机最后的最后又发生了什么？

以下是一个很简单的 C 文件编译成汇编代码后的注解：

```
#include <stdio.h>
#include <math.h>

int square(int a，int b){
    return a*b;
}

int fp(int b)
{
    int a = 1;
    return square(a+b，a+b);
}

int main()
{
    int sum = 1;
    for(int a = 0;a < 100; a++){
        sum = sum + fp(a);
    }
    return sum;
}
```

```
//编译器: armv7-a clang (trunk)
square(int， int):
        sub     sp， sp， #8     @sp减去8，意思为给square分配栈空间，只用2个栈空间完成计算
        str     r0， [sp， #4]   @第一个参数入栈
        str     r1， [sp]       @第二个参数入栈
        ldr     r1， [sp， #4]   @取出第一个参数给r1
        ldr     r2， [sp]       @取出第二个参数给r2
        mul     r0， r1， r2     @执行a*b给R0，返回值的工作一直是交给R0的
        add     sp， sp， #8     @函数执行完了，要释放申请的栈空间
        bx      lr             @子程序返回，等同于mov pc，lr，即跳到调用处
fp(int):
        push    {r11， lr}      @r11(fp)/lr入栈，保存调用者main的位置
        mov     r11， sp        @r11用于保存sp值，函数栈开始位置 
        sub     sp， sp， #8     @sp减去8，意思为给fp分配栈空间，只用2个栈空间完成计算
        str     r0， [sp， #4]   @先保存参数值，放在SP+4，此时r0中存放的是参数
        mov     r0， #1         @r0=1
        str     r0， [sp]       @再把1也保存在SP的位置
        ldr     r0， [sp]       @把SP的值给R0
        ldr     r1， [sp， #4]   @把SP+4的值给R1
        add     r1， r0， r1     @执行r1=a+b
        mov     r0， r1         @r0=r1，用r0，r1传参
        bl      square(int， int)@先mov lr， pc 再mov pc square(int， int)   
        mov     sp， r11        @函数执行完了，要释放申请的栈空间 
        pop     {r11， lr}      @弹出r11和lr，lr是专用标签，弹出就自动复制给lr寄存器
        bx      lr             @子程序返回，等同于mov pc，lr，即跳到调用处
main:
        push    {r11， lr}      @r11(fp)/lr入栈，保存调用者的位置
        mov     r11， sp        @r11用于保存sp值，函数栈开始位置
        sub     sp， sp， #16    @sp减去8，意思为给main分配栈空间，只用2个栈空间完成计算
        mov     r0， #0         @初始化r0
        str     r0， [r11， #-4] @作用是保存SUM的初始值 
        str     r0， [sp， #8]   @sum将始终占用SP+8的位置
        str     r0， [sp， #4]   @a将始终占用SP+4的位置
        b       .LBB1_1        @跳到循环开始位置
.LBB1_1:                       @循环开始位置入口
        ldr     r0， [sp， #4]   @取出a的值给r0
        cmp     r0， #99        @跟99比较
        bgt     .LBB1_4        @大于99，跳出循环 mov pc .LBB1_4
        b       .LBB1_2        @继续循环，直接 mov pc .LBB1_2
.LBB1_2:                       @符合循环条件入口
        ldr     r0， [sp， #8]   @取出sum的值给r0，sp+8用于写SUM的值
        str     r0， [sp]       @先保存SUM的值，SP的位置用于读SUM值
        ldr     r0， [sp， #4]   @r0用于传参，取出A的值给r0作为fp的参数
        bl      fp(int)        @先mov lr， pc再mov pc fp(int)
        mov     r1， r0         @fp的返回值为r0，保存到r1
        ldr     r0， [sp]       @取出SUM的值
        add     r0， r0， r1     @计算新sum的值，由R0保存
        str     r0， [sp， #8]   @将新sum保存到SP+8的位置
        b       .LBB1_3        @无条件跳转，直接 mov pc .LBB1_3
.LBB1_3:                       @完成a++操作入口
        ldr     r0， [sp， #4]   @SP+4中记录是a的值，赋给r0
        add     r0， r0， #1     @r0增加1
        str     r0， [sp， #4]   @把新的a值放回SP+4里去
        b       .LBB1_1        @跳转到比较 a < 100 处
.LBB1_4:                       @循环结束入口
        ldr     r0， [sp， #8]   @最后SUM的结果给R0，返回值的工作一直是交给R0的
        mov     sp， r11        @函数执行完了，要释放申请的栈空间
        pop     {r11， lr}      @弹出r11和lr，lr是专用标签，弹出就自动复制给lr寄存器
        bx      lr             @子程序返回，跳转到lr处等同于 MOV PC， LR
```

这个简单的汇编并不是鸿蒙的汇编，只是先打个底，由浅入深，但看懂了它基本理解鸿蒙汇编代码没有问题， 后续将详细分析鸿蒙内核各个汇编文件的作用。开始分析上面的汇编代码：

***第一***：上面的代码和鸿蒙内核用栈方式一样，都采用了递减满栈的方式， 什么是递减满栈？递减指的是栈底地址高于栈顶地址，满栈指的是 SP 指针永远在栈顶。一定要理解递减满栈，否则读不懂内核汇编代码。举例说明:

```
square(int， int):
        sub     sp， sp， #8     @sp减去8，意思为给square分配栈空间，只用2个栈空间完成计算
        str     r0， [sp， #4]   @第一个参数入栈
        str     r1， [sp]       @第二个参数入栈
        ldr     r1， [sp， #4]   @取出第一个参数给r1
        ldr     r2， [sp]       @取出第二个参数给r2
        mul     r0， r1， r2     @执行a*b给R0，返回值的工作一直是交给R0的
        add     sp， sp， #8     @函数执行完了，要释放申请的栈空间
        bx      lr             @子程序返回，等同于mov pc，lr，即跳到调用处
```

首句汇编的含义就是申请栈空间， sp = sp - 8 ，一个栈内单元 (栈空间) 占 4 个字节，申请 2 个栈空间搞定函数的计算，仔细看下代码除了在函数的末尾 sp = sp + 8 又恢复在之前的位置的中间过程，SP 的值是没有任务变化，它的指向是不动的， 这跟很多人对栈的认知是不一样的，它只是被用于计算，例如 ldr r1， [sp， #4] 的意思是取出 SP+4 这个虚拟地址的值给 r1 寄存器，SP 的值并没有改变的，为什么要 + 呢，因为 SP 是指向栈顶的，地址是最小的。满栈就是用栈过程中对地址的操作不能超过 SP，所以你很少在计算过程中看到 把 sp-4 地址中的值给某个寄存器， 除非是特别的指令，否则不可能有这样的指令.

***第二***： sub sp， sp， #8 和 add sp， sp， #8 是成对出现的，这就跟申请内存，释放内存的道理一样，这是内核对任务的运行栈管理方式，一样用多少申请多少，用完释放。空间大小就是栈帧，这是栈帧的本质含义.

***第三***： push {r11， lr} 和 pop {r11， lr} 也是成对出现的，主要是用于函数调用，例如 A -> B， B 要保存 A 的栈帧范围和指令位置， lr 保存的是 A 函数执行到哪个指令的位置， r11 干了 fp 的工作，其实就是指向 A 的栈顶位置，如此 B 执行完后 return 回 A 的时候，先 mov pc，lr 内核就知道改执行 A 的哪条指令了，同时又知道了 A 的栈顶位置.

***第四***： 频繁出现的 R0 寄存器的作用是传参和返回值， A 调用 B 之前，假如有两个参数，就把参数给 r0 ，r1 记录，充当了 A 的变量， 到了 B 中后，先让 r0，r1 入栈，目的是保存参数值， 因为 B 中要用 r0，r1 ，他们变成 B 的变量用了。返回值都是默认统一给 r0 保存， B 中将返回值给 r0，回到 A 中取出 R0 值对 A 来说这就是 B 的返回值.

这是以上为汇编代码的分析，追问两个问题

第一：如果是可变参数怎么办？100 个参数怎么整， 通过寄存器总共就 12 个，不够传参啊 第二：返回值可以有多个吗？
